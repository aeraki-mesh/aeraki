// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: api/dubbo/v1alpha1/dubbo_authorization_policy.proto

//
// Authorization Policy scope (target) is determined by "metadata/namespace" and
// an optional "selector".
//
// - "metadata/namespace" tells which namespace the policy applies. If set to root
// namespace, the policy applies to all namespaces in a mesh.

package v1alpha1

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	_ "istio.io/gogo-genproto/googleapis/google/api"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Action specifies the operation to take.
type DubboAuthorizationPolicy_Action int32

const (
	// Allow a request only if it matches the rules. This is the default type.
	DubboAuthorizationPolicy_ALLOW DubboAuthorizationPolicy_Action = 0
	// Deny a request if it matches any of the rules.
	DubboAuthorizationPolicy_DENY DubboAuthorizationPolicy_Action = 1
)

var DubboAuthorizationPolicy_Action_name = map[int32]string{
	0: "ALLOW",
	1: "DENY",
}

var DubboAuthorizationPolicy_Action_value = map[string]int32{
	"ALLOW": 0,
	"DENY":  1,
}

func (x DubboAuthorizationPolicy_Action) String() string {
	return proto.EnumName(DubboAuthorizationPolicy_Action_name, int32(x))
}

func (DubboAuthorizationPolicy_Action) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f805ac8c1ee0a237, []int{0, 0}
}

// DubboAuthorizationPolicy enables access control on Dubbo services.
//
// <!-- crd generation tags
// +cue-gen:DubboAuthorizationPolicy:groupName:dubbo.aeraki.io
// +cue-gen:DubboAuthorizationPolicy:version:v1alpha1
// +cue-gen:DubboAuthorizationPolicy:storageVersion
// +cue-gen:DubboAuthorizationPolicy:annotations:helm.sh/resource-policy=keep
// +cue-gen:DubboAuthorizationPolicy:labels:app=aeraki,chart=aeraki,heritage=Tiller,release=aeraki
// +cue-gen:DubboAuthorizationPolicy:subresource:status
// +cue-gen:DubboAuthorizationPolicy:scope:Namespaced
// +cue-gen:DubboAuthorizationPolicy:resource:categories=aeraki-io,dubbo-aeraki-io,plural=dubboauthorizationpolicies,shortNames=dap
// +cue-gen:DubboAuthorizationPolicy:preserveUnknownFields:false
// -->
//
// <!-- go code generation tags
// +kubetype-gen
// +kubetype-gen:groupVersion=dubbo.aeraki.io/v1alpha1
// +genclient
// +k8s:deepcopy-gen=true
// -->
type DubboAuthorizationPolicy struct {
	// Optional. A list of rules to match the request. A match occurs when at least
	// one rule matches the request.
	//
	// If not set, the match will never occur. This is equivalent to setting a
	// default of deny for the target workloads.
	Rules []*Rule `protobuf:"bytes,2,rep,name=rules,proto3" json:"rules,omitempty"`
	// Optional. The action to take if the request is matched with the rules.
	Action               DubboAuthorizationPolicy_Action `protobuf:"varint,3,opt,name=action,proto3,enum=dubbo.aeraki.io.v1alpha1.DubboAuthorizationPolicy_Action" json:"action,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                        `json:"-"`
	XXX_unrecognized     []byte                          `json:"-"`
	XXX_sizecache        int32                           `json:"-"`
}

func (m *DubboAuthorizationPolicy) Reset()         { *m = DubboAuthorizationPolicy{} }
func (m *DubboAuthorizationPolicy) String() string { return proto.CompactTextString(m) }
func (*DubboAuthorizationPolicy) ProtoMessage()    {}
func (*DubboAuthorizationPolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor_f805ac8c1ee0a237, []int{0}
}
func (m *DubboAuthorizationPolicy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DubboAuthorizationPolicy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DubboAuthorizationPolicy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DubboAuthorizationPolicy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DubboAuthorizationPolicy.Merge(m, src)
}
func (m *DubboAuthorizationPolicy) XXX_Size() int {
	return m.Size()
}
func (m *DubboAuthorizationPolicy) XXX_DiscardUnknown() {
	xxx_messageInfo_DubboAuthorizationPolicy.DiscardUnknown(m)
}

var xxx_messageInfo_DubboAuthorizationPolicy proto.InternalMessageInfo

func (m *DubboAuthorizationPolicy) GetRules() []*Rule {
	if m != nil {
		return m.Rules
	}
	return nil
}

func (m *DubboAuthorizationPolicy) GetAction() DubboAuthorizationPolicy_Action {
	if m != nil {
		return m.Action
	}
	return DubboAuthorizationPolicy_ALLOW
}

// Rule matches requests from a list of sources that perform a list of operations subject to a
// list of conditions. A match occurs when at least one source, one operation and all conditions
// matches the request. An empty rule is always matched.
//
// Any string field in the rule supports Exact, Prefix, Suffix and Presence match:
//
// - Exact match: "abc" will match on value "abc".
// - Prefix match: "abc*" will match on value "abc" and "abcd".
// - Suffix match: "*abc" will match on value "abc" and "xabc".
// - Presence match: "*" will match when value is not empty.
type Rule struct {
	// Optional. from specifies the source of a request.
	//
	// If not set, any source is allowed.
	From []*Rule_From `protobuf:"bytes,1,rep,name=from,proto3" json:"from,omitempty"`
	// Optional. to specifies the operation of a request.
	//
	// If not set, any operation is allowed.
	To                   []*Rule_To `protobuf:"bytes,2,rep,name=to,proto3" json:"to,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *Rule) Reset()         { *m = Rule{} }
func (m *Rule) String() string { return proto.CompactTextString(m) }
func (*Rule) ProtoMessage()    {}
func (*Rule) Descriptor() ([]byte, []int) {
	return fileDescriptor_f805ac8c1ee0a237, []int{1}
}
func (m *Rule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Rule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Rule.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Rule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Rule.Merge(m, src)
}
func (m *Rule) XXX_Size() int {
	return m.Size()
}
func (m *Rule) XXX_DiscardUnknown() {
	xxx_messageInfo_Rule.DiscardUnknown(m)
}

var xxx_messageInfo_Rule proto.InternalMessageInfo

func (m *Rule) GetFrom() []*Rule_From {
	if m != nil {
		return m.From
	}
	return nil
}

func (m *Rule) GetTo() []*Rule_To {
	if m != nil {
		return m.To
	}
	return nil
}

// From includes a list or sources.
type Rule_From struct {
	// Source specifies the source of a request.
	Source               *Source  `protobuf:"bytes,1,opt,name=source,proto3" json:"source,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Rule_From) Reset()         { *m = Rule_From{} }
func (m *Rule_From) String() string { return proto.CompactTextString(m) }
func (*Rule_From) ProtoMessage()    {}
func (*Rule_From) Descriptor() ([]byte, []int) {
	return fileDescriptor_f805ac8c1ee0a237, []int{1, 0}
}
func (m *Rule_From) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Rule_From) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Rule_From.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Rule_From) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Rule_From.Merge(m, src)
}
func (m *Rule_From) XXX_Size() int {
	return m.Size()
}
func (m *Rule_From) XXX_DiscardUnknown() {
	xxx_messageInfo_Rule_From.DiscardUnknown(m)
}

var xxx_messageInfo_Rule_From proto.InternalMessageInfo

func (m *Rule_From) GetSource() *Source {
	if m != nil {
		return m.Source
	}
	return nil
}

// To includes a list or operations.
type Rule_To struct {
	// Operation specifies the operation of a request.
	Operation            *Operation `protobuf:"bytes,1,opt,name=operation,proto3" json:"operation,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *Rule_To) Reset()         { *m = Rule_To{} }
func (m *Rule_To) String() string { return proto.CompactTextString(m) }
func (*Rule_To) ProtoMessage()    {}
func (*Rule_To) Descriptor() ([]byte, []int) {
	return fileDescriptor_f805ac8c1ee0a237, []int{1, 1}
}
func (m *Rule_To) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Rule_To) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Rule_To.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Rule_To) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Rule_To.Merge(m, src)
}
func (m *Rule_To) XXX_Size() int {
	return m.Size()
}
func (m *Rule_To) XXX_DiscardUnknown() {
	xxx_messageInfo_Rule_To.DiscardUnknown(m)
}

var xxx_messageInfo_Rule_To proto.InternalMessageInfo

func (m *Rule_To) GetOperation() *Operation {
	if m != nil {
		return m.Operation
	}
	return nil
}

// Source specifies the source identities of a request. Fields in the source are
// ANDed together.
//
// For example, the following source matches if the principal is "admin" or "dev"
// and the namespace is "prod" or "test".
//
// ```yaml
// principals: ["admin", "dev"]
// namespaces: ["prod", "test"]
// ```
type Source struct {
	// Optional. A list of source peer identities (i.e. service account), which
	// matches to the "source.principal" attribute. This field requires mTLS enabled.
	//
	// If not set, any principal is allowed.
	Principals []string `protobuf:"bytes,1,rep,name=principals,proto3" json:"principals,omitempty"`
	// Optional. A list of negative match of source peer identities.
	NotPrincipals []string `protobuf:"bytes,2,rep,name=not_principals,json=notPrincipals,proto3" json:"not_principals,omitempty"`
	// Optional. A list of namespaces, which matches to the "source.namespace"
	// attribute. This field requires mTLS enabled.
	//
	// If not set, any namespace is allowed.
	Namespaces []string `protobuf:"bytes,3,rep,name=namespaces,proto3" json:"namespaces,omitempty"`
	// Optional. A list of negative match of namespaces.
	NotNamespaces        []string `protobuf:"bytes,4,rep,name=not_namespaces,json=notNamespaces,proto3" json:"not_namespaces,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Source) Reset()         { *m = Source{} }
func (m *Source) String() string { return proto.CompactTextString(m) }
func (*Source) ProtoMessage()    {}
func (*Source) Descriptor() ([]byte, []int) {
	return fileDescriptor_f805ac8c1ee0a237, []int{2}
}
func (m *Source) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Source) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Source.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Source) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Source.Merge(m, src)
}
func (m *Source) XXX_Size() int {
	return m.Size()
}
func (m *Source) XXX_DiscardUnknown() {
	xxx_messageInfo_Source.DiscardUnknown(m)
}

var xxx_messageInfo_Source proto.InternalMessageInfo

func (m *Source) GetPrincipals() []string {
	if m != nil {
		return m.Principals
	}
	return nil
}

func (m *Source) GetNotPrincipals() []string {
	if m != nil {
		return m.NotPrincipals
	}
	return nil
}

func (m *Source) GetNamespaces() []string {
	if m != nil {
		return m.Namespaces
	}
	return nil
}

func (m *Source) GetNotNamespaces() []string {
	if m != nil {
		return m.NotNamespaces
	}
	return nil
}

// Operation specifies the operations of a request. Fields in the operation are
// ANDed together.
//
// For example, the following operation matches if the Dubbo interface is "org.apache.dubbo.samples.basic.api.DemoService"
// and the method is "sayHello".
//
// ```yaml
// interfaces: ["org.apache.dubbo.samples.basic.api.DemoService"]
// methods: ["sayHello"]
// ```
type Operation struct {
	// Optional. A list of interfaces, which matches to the Dubbo interface.
	//
	// If not set, any interfaces is allowed.
	Interfaces []string `protobuf:"bytes,1,rep,name=interfaces,proto3" json:"interfaces,omitempty"`
	// Optional. A list of negative match of interfaces.
	NotInterfaces []string `protobuf:"bytes,5,rep,name=not_interfaces,json=notInterfaces,proto3" json:"not_interfaces,omitempty"`
	// Optional. A list of methods, which matches to the Dubbo methods.
	//
	// If not set, any method is allowed.
	Methods []string `protobuf:"bytes,3,rep,name=methods,proto3" json:"methods,omitempty"`
	// Optional. A list of negative match of methods.
	NotMethods           []string `protobuf:"bytes,7,rep,name=not_methods,json=notMethods,proto3" json:"not_methods,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Operation) Reset()         { *m = Operation{} }
func (m *Operation) String() string { return proto.CompactTextString(m) }
func (*Operation) ProtoMessage()    {}
func (*Operation) Descriptor() ([]byte, []int) {
	return fileDescriptor_f805ac8c1ee0a237, []int{3}
}
func (m *Operation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Operation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Operation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Operation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Operation.Merge(m, src)
}
func (m *Operation) XXX_Size() int {
	return m.Size()
}
func (m *Operation) XXX_DiscardUnknown() {
	xxx_messageInfo_Operation.DiscardUnknown(m)
}

var xxx_messageInfo_Operation proto.InternalMessageInfo

func (m *Operation) GetInterfaces() []string {
	if m != nil {
		return m.Interfaces
	}
	return nil
}

func (m *Operation) GetNotInterfaces() []string {
	if m != nil {
		return m.NotInterfaces
	}
	return nil
}

func (m *Operation) GetMethods() []string {
	if m != nil {
		return m.Methods
	}
	return nil
}

func (m *Operation) GetNotMethods() []string {
	if m != nil {
		return m.NotMethods
	}
	return nil
}

func init() {
	proto.RegisterEnum("dubbo.aeraki.io.v1alpha1.DubboAuthorizationPolicy_Action", DubboAuthorizationPolicy_Action_name, DubboAuthorizationPolicy_Action_value)
	proto.RegisterType((*DubboAuthorizationPolicy)(nil), "dubbo.aeraki.io.v1alpha1.DubboAuthorizationPolicy")
	proto.RegisterType((*Rule)(nil), "dubbo.aeraki.io.v1alpha1.Rule")
	proto.RegisterType((*Rule_From)(nil), "dubbo.aeraki.io.v1alpha1.Rule.From")
	proto.RegisterType((*Rule_To)(nil), "dubbo.aeraki.io.v1alpha1.Rule.To")
	proto.RegisterType((*Source)(nil), "dubbo.aeraki.io.v1alpha1.Source")
	proto.RegisterType((*Operation)(nil), "dubbo.aeraki.io.v1alpha1.Operation")
}

func init() {
	proto.RegisterFile("api/dubbo/v1alpha1/dubbo_authorization_policy.proto", fileDescriptor_f805ac8c1ee0a237)
}

var fileDescriptor_f805ac8c1ee0a237 = []byte{
	// 476 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x93, 0x41, 0x8b, 0xd3, 0x4c,
	0x18, 0xc7, 0xdf, 0x69, 0xd3, 0xec, 0xdb, 0xa7, 0xb8, 0x2c, 0x73, 0x0a, 0x05, 0xb3, 0x35, 0x22,
	0xf4, 0x62, 0x62, 0xbb, 0x82, 0x7a, 0x11, 0x2b, 0xab, 0x22, 0xac, 0xbb, 0x6b, 0x5c, 0x10, 0xbd,
	0x94, 0x49, 0x3a, 0x6d, 0x06, 0x93, 0x3c, 0x61, 0x32, 0x59, 0xd0, 0xef, 0xe0, 0xd5, 0x0f, 0xe4,
	0xc9, 0xa3, 0x1f, 0x41, 0xfa, 0x3d, 0x04, 0xc9, 0x24, 0x69, 0x02, 0xd2, 0xf5, 0x96, 0x79, 0xf2,
	0xfb, 0xff, 0xe6, 0x3f, 0x03, 0x03, 0x27, 0x2c, 0x13, 0xde, 0xaa, 0x08, 0x02, 0xf4, 0xae, 0x67,
	0x2c, 0xce, 0x22, 0x36, 0xab, 0x96, 0x4b, 0x56, 0xa8, 0x08, 0xa5, 0xf8, 0xc2, 0x94, 0xc0, 0x74,
	0x99, 0x61, 0x2c, 0xc2, 0xcf, 0x6e, 0x26, 0x51, 0x21, 0xb5, 0x34, 0xe1, 0x32, 0x2e, 0xd9, 0x27,
	0xe1, 0x0a, 0x74, 0x9b, 0xe8, 0xf8, 0x78, 0x83, 0xb8, 0x89, 0xb9, 0x57, 0x5a, 0xd7, 0x82, 0xc7,
	0xab, 0x65, 0xc0, 0x23, 0x76, 0x2d, 0x50, 0x56, 0x51, 0xe7, 0x3b, 0x01, 0xeb, 0xb4, 0x4c, 0x2f,
	0xba, 0xfa, 0x4b, 0x6d, 0xa7, 0x0f, 0x61, 0x20, 0x8b, 0x98, 0xe7, 0x56, 0x6f, 0xd2, 0x9f, 0x8e,
	0xe6, 0xb6, 0xbb, 0x6f, 0x1f, 0xd7, 0x2f, 0x62, 0xee, 0x57, 0x30, 0x7d, 0x0b, 0x26, 0x0b, 0x4b,
	0x8b, 0xd5, 0x9f, 0x90, 0xe9, 0xe1, 0xfc, 0xc9, 0xfe, 0xd8, 0xbe, 0x9d, 0xdd, 0x85, 0x16, 0xf8,
	0xb5, 0xc8, 0xb9, 0x0d, 0x66, 0x35, 0xa1, 0x43, 0x18, 0x2c, 0xce, 0xce, 0x2e, 0xde, 0x1f, 0xfd,
	0x47, 0xff, 0x07, 0xe3, 0xf4, 0xc5, 0xf9, 0x87, 0x23, 0xe2, 0xfc, 0x26, 0x60, 0x94, 0x0d, 0xe8,
	0x23, 0x30, 0xd6, 0x12, 0x13, 0x8b, 0xe8, 0xbe, 0x77, 0x6f, 0xee, 0xeb, 0xbe, 0x94, 0x98, 0xf8,
	0x3a, 0x40, 0x67, 0xd0, 0x53, 0x58, 0x1f, 0xf3, 0xce, 0x3f, 0x62, 0x57, 0xe8, 0xf7, 0x14, 0x8e,
	0x9f, 0x81, 0x51, 0x0a, 0xe8, 0x63, 0x30, 0x73, 0x2c, 0x64, 0xc8, 0x2d, 0x32, 0x21, 0xd3, 0xd1,
	0x7c, 0xb2, 0x3f, 0xfe, 0x4e, 0x73, 0x7e, 0xcd, 0x8f, 0x5f, 0x41, 0xef, 0x0a, 0xe9, 0x02, 0x86,
	0x98, 0x71, 0xa9, 0x4f, 0x5f, 0x2b, 0x6e, 0x28, 0x7e, 0xd1, 0xa0, 0x7e, 0x9b, 0x72, 0xbe, 0x11,
	0x30, 0x2b, 0x37, 0xb5, 0x01, 0x32, 0x29, 0xd2, 0x50, 0x64, 0x2c, 0xce, 0xf5, 0x3d, 0x0c, 0xfd,
	0xce, 0x84, 0xde, 0x83, 0xc3, 0x14, 0xd5, 0xb2, 0xc3, 0xf4, 0x34, 0x73, 0x2b, 0x45, 0x75, 0xd9,
	0x62, 0x36, 0x40, 0xca, 0x12, 0x9e, 0x67, 0x2c, 0xe4, 0xb9, 0xd5, 0xaf, 0x34, 0xed, 0xa4, 0xd1,
	0x74, 0x18, 0x63, 0xa7, 0x39, 0xdf, 0x0d, 0x9d, 0xaf, 0x04, 0x86, 0xbb, 0xc6, 0xa5, 0x54, 0xa4,
	0x8a, 0xcb, 0xb5, 0x0e, 0xd4, 0xdd, 0xda, 0x49, 0x23, 0xed, 0x30, 0x83, 0x9d, 0xf4, 0x75, 0x8b,
	0x59, 0x70, 0x90, 0x70, 0x15, 0xe1, 0xaa, 0x29, 0xd6, 0x2c, 0xe9, 0x31, 0x8c, 0x4a, 0x41, 0xf3,
	0xf7, 0xa0, 0xae, 0x8d, 0xea, 0x4d, 0x35, 0x79, 0xfe, 0xf4, 0xc7, 0xd6, 0x26, 0x3f, 0xb7, 0x36,
	0xf9, 0xb5, 0xb5, 0xc9, 0xc7, 0x07, 0x1b, 0xa1, 0xa2, 0x22, 0x70, 0x43, 0x4c, 0xbc, 0xea, 0xaa,
	0xef, 0x27, 0x3c, 0x8f, 0xea, 0x6f, 0xef, 0xef, 0x97, 0x18, 0x98, 0xfa, 0xd1, 0x9c, 0xfc, 0x09,
	0x00, 0x00, 0xff, 0xff, 0x51, 0x69, 0x2b, 0x62, 0xa6, 0x03, 0x00, 0x00,
}

func (m *DubboAuthorizationPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DubboAuthorizationPolicy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DubboAuthorizationPolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Action != 0 {
		i = encodeVarintDubboAuthorizationPolicy(dAtA, i, uint64(m.Action))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Rules) > 0 {
		for iNdEx := len(m.Rules) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Rules[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDubboAuthorizationPolicy(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	return len(dAtA) - i, nil
}

func (m *Rule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Rule) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Rule) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.To) > 0 {
		for iNdEx := len(m.To) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.To[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDubboAuthorizationPolicy(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.From) > 0 {
		for iNdEx := len(m.From) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.From[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDubboAuthorizationPolicy(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Rule_From) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Rule_From) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Rule_From) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Source != nil {
		{
			size, err := m.Source.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDubboAuthorizationPolicy(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Rule_To) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Rule_To) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Rule_To) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Operation != nil {
		{
			size, err := m.Operation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDubboAuthorizationPolicy(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Source) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Source) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Source) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.NotNamespaces) > 0 {
		for iNdEx := len(m.NotNamespaces) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.NotNamespaces[iNdEx])
			copy(dAtA[i:], m.NotNamespaces[iNdEx])
			i = encodeVarintDubboAuthorizationPolicy(dAtA, i, uint64(len(m.NotNamespaces[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Namespaces) > 0 {
		for iNdEx := len(m.Namespaces) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Namespaces[iNdEx])
			copy(dAtA[i:], m.Namespaces[iNdEx])
			i = encodeVarintDubboAuthorizationPolicy(dAtA, i, uint64(len(m.Namespaces[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.NotPrincipals) > 0 {
		for iNdEx := len(m.NotPrincipals) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.NotPrincipals[iNdEx])
			copy(dAtA[i:], m.NotPrincipals[iNdEx])
			i = encodeVarintDubboAuthorizationPolicy(dAtA, i, uint64(len(m.NotPrincipals[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Principals) > 0 {
		for iNdEx := len(m.Principals) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Principals[iNdEx])
			copy(dAtA[i:], m.Principals[iNdEx])
			i = encodeVarintDubboAuthorizationPolicy(dAtA, i, uint64(len(m.Principals[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Operation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Operation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Operation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.NotMethods) > 0 {
		for iNdEx := len(m.NotMethods) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.NotMethods[iNdEx])
			copy(dAtA[i:], m.NotMethods[iNdEx])
			i = encodeVarintDubboAuthorizationPolicy(dAtA, i, uint64(len(m.NotMethods[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.NotInterfaces) > 0 {
		for iNdEx := len(m.NotInterfaces) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.NotInterfaces[iNdEx])
			copy(dAtA[i:], m.NotInterfaces[iNdEx])
			i = encodeVarintDubboAuthorizationPolicy(dAtA, i, uint64(len(m.NotInterfaces[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Methods) > 0 {
		for iNdEx := len(m.Methods) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Methods[iNdEx])
			copy(dAtA[i:], m.Methods[iNdEx])
			i = encodeVarintDubboAuthorizationPolicy(dAtA, i, uint64(len(m.Methods[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Interfaces) > 0 {
		for iNdEx := len(m.Interfaces) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Interfaces[iNdEx])
			copy(dAtA[i:], m.Interfaces[iNdEx])
			i = encodeVarintDubboAuthorizationPolicy(dAtA, i, uint64(len(m.Interfaces[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintDubboAuthorizationPolicy(dAtA []byte, offset int, v uint64) int {
	offset -= sovDubboAuthorizationPolicy(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *DubboAuthorizationPolicy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Rules) > 0 {
		for _, e := range m.Rules {
			l = e.Size()
			n += 1 + l + sovDubboAuthorizationPolicy(uint64(l))
		}
	}
	if m.Action != 0 {
		n += 1 + sovDubboAuthorizationPolicy(uint64(m.Action))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Rule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.From) > 0 {
		for _, e := range m.From {
			l = e.Size()
			n += 1 + l + sovDubboAuthorizationPolicy(uint64(l))
		}
	}
	if len(m.To) > 0 {
		for _, e := range m.To {
			l = e.Size()
			n += 1 + l + sovDubboAuthorizationPolicy(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Rule_From) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Source != nil {
		l = m.Source.Size()
		n += 1 + l + sovDubboAuthorizationPolicy(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Rule_To) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Operation != nil {
		l = m.Operation.Size()
		n += 1 + l + sovDubboAuthorizationPolicy(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Source) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Principals) > 0 {
		for _, s := range m.Principals {
			l = len(s)
			n += 1 + l + sovDubboAuthorizationPolicy(uint64(l))
		}
	}
	if len(m.NotPrincipals) > 0 {
		for _, s := range m.NotPrincipals {
			l = len(s)
			n += 1 + l + sovDubboAuthorizationPolicy(uint64(l))
		}
	}
	if len(m.Namespaces) > 0 {
		for _, s := range m.Namespaces {
			l = len(s)
			n += 1 + l + sovDubboAuthorizationPolicy(uint64(l))
		}
	}
	if len(m.NotNamespaces) > 0 {
		for _, s := range m.NotNamespaces {
			l = len(s)
			n += 1 + l + sovDubboAuthorizationPolicy(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Operation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Interfaces) > 0 {
		for _, s := range m.Interfaces {
			l = len(s)
			n += 1 + l + sovDubboAuthorizationPolicy(uint64(l))
		}
	}
	if len(m.Methods) > 0 {
		for _, s := range m.Methods {
			l = len(s)
			n += 1 + l + sovDubboAuthorizationPolicy(uint64(l))
		}
	}
	if len(m.NotInterfaces) > 0 {
		for _, s := range m.NotInterfaces {
			l = len(s)
			n += 1 + l + sovDubboAuthorizationPolicy(uint64(l))
		}
	}
	if len(m.NotMethods) > 0 {
		for _, s := range m.NotMethods {
			l = len(s)
			n += 1 + l + sovDubboAuthorizationPolicy(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovDubboAuthorizationPolicy(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozDubboAuthorizationPolicy(x uint64) (n int) {
	return sovDubboAuthorizationPolicy(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *DubboAuthorizationPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDubboAuthorizationPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DubboAuthorizationPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DubboAuthorizationPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDubboAuthorizationPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDubboAuthorizationPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDubboAuthorizationPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rules = append(m.Rules, &Rule{})
			if err := m.Rules[len(m.Rules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			m.Action = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDubboAuthorizationPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Action |= DubboAuthorizationPolicy_Action(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDubboAuthorizationPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDubboAuthorizationPolicy
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDubboAuthorizationPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Rule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDubboAuthorizationPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Rule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Rule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDubboAuthorizationPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDubboAuthorizationPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDubboAuthorizationPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = append(m.From, &Rule_From{})
			if err := m.From[len(m.From)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDubboAuthorizationPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDubboAuthorizationPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDubboAuthorizationPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.To = append(m.To, &Rule_To{})
			if err := m.To[len(m.To)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDubboAuthorizationPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDubboAuthorizationPolicy
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDubboAuthorizationPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Rule_From) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDubboAuthorizationPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: From: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: From: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDubboAuthorizationPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDubboAuthorizationPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDubboAuthorizationPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Source == nil {
				m.Source = &Source{}
			}
			if err := m.Source.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDubboAuthorizationPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDubboAuthorizationPolicy
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDubboAuthorizationPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Rule_To) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDubboAuthorizationPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: To: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: To: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDubboAuthorizationPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDubboAuthorizationPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDubboAuthorizationPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Operation == nil {
				m.Operation = &Operation{}
			}
			if err := m.Operation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDubboAuthorizationPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDubboAuthorizationPolicy
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDubboAuthorizationPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Source) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDubboAuthorizationPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Source: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Source: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Principals", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDubboAuthorizationPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDubboAuthorizationPolicy
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDubboAuthorizationPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Principals = append(m.Principals, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotPrincipals", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDubboAuthorizationPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDubboAuthorizationPolicy
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDubboAuthorizationPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NotPrincipals = append(m.NotPrincipals, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespaces", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDubboAuthorizationPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDubboAuthorizationPolicy
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDubboAuthorizationPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespaces = append(m.Namespaces, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotNamespaces", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDubboAuthorizationPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDubboAuthorizationPolicy
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDubboAuthorizationPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NotNamespaces = append(m.NotNamespaces, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDubboAuthorizationPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDubboAuthorizationPolicy
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDubboAuthorizationPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Operation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDubboAuthorizationPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Operation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Operation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interfaces", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDubboAuthorizationPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDubboAuthorizationPolicy
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDubboAuthorizationPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Interfaces = append(m.Interfaces, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Methods", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDubboAuthorizationPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDubboAuthorizationPolicy
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDubboAuthorizationPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Methods = append(m.Methods, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotInterfaces", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDubboAuthorizationPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDubboAuthorizationPolicy
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDubboAuthorizationPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NotInterfaces = append(m.NotInterfaces, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotMethods", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDubboAuthorizationPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDubboAuthorizationPolicy
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDubboAuthorizationPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NotMethods = append(m.NotMethods, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDubboAuthorizationPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDubboAuthorizationPolicy
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDubboAuthorizationPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDubboAuthorizationPolicy(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDubboAuthorizationPolicy
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDubboAuthorizationPolicy
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDubboAuthorizationPolicy
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthDubboAuthorizationPolicy
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupDubboAuthorizationPolicy
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthDubboAuthorizationPolicy
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthDubboAuthorizationPolicy        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDubboAuthorizationPolicy          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupDubboAuthorizationPolicy = fmt.Errorf("proto: unexpected end of group")
)
