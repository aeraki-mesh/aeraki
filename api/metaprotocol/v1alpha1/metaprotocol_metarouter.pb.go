// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: api/metaprotocol/v1alpha1/metaprotocol_metarouter.proto

// $schema: metaprotocol.aeraki.io.v1alpha1.MetaRouter
// $title: MetaRouter
// $description: MetaRouter defines route policies for MetaProtocol proxy.
//
// MetaRouter defines route policies for MetaProtocol proxy.
// *Note*: Only one MetaRouter should be defined for a MetaProtocol service.
// If more than one MetaRouters are found for a service, Aeraki will choose
// a random one to apply to that service.
//
// *Note *: MetaRouter is a mesh-scoped resource, so no matter which namespace
// the MetaRouter is in, it will take effect on the services specified in the hosts.
//
// ```yaml
// apiVersion: metaprotocol.aeraki.io/v1alpha1
// kind: MetaRouter
// metadata:
//   name: attribute-based-route
//   namespace: istio-system
// spec:
//   hosts:
//   - org.apache.dubbo.samples.basic.api.demoservice
//   gateways:
//   - istio-system/ingress-gateway
//   routes:
//   - name: v1
//     match:
//       attributes:
//         interface:
//           exact: org.apache.dubbo.samples.basic.api.DemoService
//         method:
//           exact: sayHello
//     route:
//     - destination:
//         host: org.apache.dubbo.samples.basic.api.demoservice
//         subset: v1
//
// ```
//
// ```yaml
// apiVersion: metaprotocol.aeraki.io/v1alpha1
// kind: MetaRouter
// metadata:
//   name: traffic-splitting
// spec:
//   hosts:
//     - org.apache.dubbo.samples.basic.api.demoservice
//   routes:
//     - name: traffic-spilt
//       route:
//         - destination:
//             host: org.apache.dubbo.samples.basic.api.demoservice
//             subset: v1
//           weight: 20
//         - destination:
//             host: org.apache.dubbo.samples.basic.api.demoservice
//             subset: v2
//           weight: 80

package v1alpha1

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	io "io"
	_ "istio.io/gogo-genproto/googleapis/google/api"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// MetaRouter defines route policies for MetaProtocol proxy.
//
// <!-- crd generation tags
// +cue-gen:MetaRouter:groupName:metaprotocol.aeraki.io
// +cue-gen:MetaRouter:version:v1alpha1
// +cue-gen:MetaRouter:storageVersion
// +cue-gen:MetaRouter:annotations:helm.sh/resource-policy=keep
// +cue-gen:MetaRouter:labels:app=aeraki,chart=aeraki,heritage=Tiller,release=aeraki
// +cue-gen:MetaRouter:subresource:status
// +cue-gen:MetaRouter:scope:Namespaced
// +cue-gen:MetaRouter:resource:categories=aeraki-io,metaprotocol-aeraki-io
// +cue-gen:MetaRouter:preserveUnknownFields:false
// -->
//
// <!-- go code generation tags
// +kubetype-gen
// +kubetype-gen:groupVersion=metaprotocol.aeraki.io/v1alpha1
// +genclient
// +k8s:deepcopy-gen=true
// -->
type MetaRouter struct {
	// The destination service to which traffic is being sent.
	// *Note for Kubernetes users*: It must be a fully qualified domain name
	// (FQDN), (e.g. "thrift-sample-server.meta-thrift.svc.cluster.local" )
	// instead of a short name (e.g. "thrift-sample-server").
	// *Note*: Only one host is supported now. If multiple hosts are specified,
	// Only the first one takes effect.
	Hosts []string `protobuf:"bytes,1,rep,name=hosts,proto3" json:"hosts,omitempty"`
	// The names of gateways and sidecars that should apply these routes. The usage of
	//  this field is the same as istio.io/VirtualService
	Gateways []string `protobuf:"bytes,2,rep,name=gateways,proto3" json:"gateways,omitempty"`
	// An ordered list of route rules for MetaProtocol traffic. The route rules
	// will be applied to service ports named "tcp-metaprotocol-${applicationProtocol}-*",
	// (e.g. "tcp-metaprotocol-thrift-hello-server"). Order maters in the routes,
	// The first rule matching an incoming request is used.
	Routes []*MetaRoute `protobuf:"bytes,3,rep,name=routes,proto3" json:"routes,omitempty"`
	// Loacal rate limit policy.
	LocalRateLimit *LocalRateLimit `protobuf:"bytes,4,opt,name=local_rate_limit,json=localRateLimit,proto3" json:"local_rate_limit,omitempty"`
	// Global rate limit policy.
	GlobalRateLimit *GlobalRateLimit `protobuf:"bytes,5,opt,name=global_rate_limit,json=globalRateLimit,proto3" json:"global_rate_limit,omitempty"`
	// A list of namespaces to which this MetaRouter is exported. Exporting a
	// MetaRouter allows it to be used by sidecars defined in other namespaces.
	// This feature provides a mechanism for service owners and mesh administrators
	// to control the visibility of MetaRouter across namespace boundaries.
	//
	// If no namespaces are specified then the MetaRouter is exported to all namespaces
	// by default.
	//
	// The value "." is reserved and defines an export to the same namespace that
	// the MetaRouter is declared in. Similarly the value "*" is reserved and
	// defines an export to all namespaces.
	ExportTo             []string `protobuf:"bytes,20,rep,name=export_to,json=exportTo,proto3" json:"export_to,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MetaRouter) Reset()         { *m = MetaRouter{} }
func (m *MetaRouter) String() string { return proto.CompactTextString(m) }
func (*MetaRouter) ProtoMessage()    {}
func (*MetaRouter) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e2715e051935576, []int{0}
}
func (m *MetaRouter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MetaRouter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MetaRouter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MetaRouter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetaRouter.Merge(m, src)
}
func (m *MetaRouter) XXX_Size() int {
	return m.Size()
}
func (m *MetaRouter) XXX_DiscardUnknown() {
	xxx_messageInfo_MetaRouter.DiscardUnknown(m)
}

var xxx_messageInfo_MetaRouter proto.InternalMessageInfo

func (m *MetaRouter) GetHosts() []string {
	if m != nil {
		return m.Hosts
	}
	return nil
}

func (m *MetaRouter) GetGateways() []string {
	if m != nil {
		return m.Gateways
	}
	return nil
}

func (m *MetaRouter) GetRoutes() []*MetaRoute {
	if m != nil {
		return m.Routes
	}
	return nil
}

func (m *MetaRouter) GetLocalRateLimit() *LocalRateLimit {
	if m != nil {
		return m.LocalRateLimit
	}
	return nil
}

func (m *MetaRouter) GetGlobalRateLimit() *GlobalRateLimit {
	if m != nil {
		return m.GlobalRateLimit
	}
	return nil
}

func (m *MetaRouter) GetExportTo() []string {
	if m != nil {
		return m.ExportTo
	}
	return nil
}

// Describes match conditions and actions for routing MetaProtocol.
type MetaRoute struct {
	// The name assigned to the route for debugging purposes.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Match conditions to be satisfied for the rule to be activated.
	// All conditions inside a single match block have AND semantic.
	Match *MetaRouteMatch `protobuf:"bytes,2,opt,name=match,proto3" json:"match,omitempty"`
	// A Route rule can forward (default) traffic. The forwarding target
	// can be one of several versions of a service (see glossary in
	// beginning of document). Weights associated with the service version
	// determine the proportion of traffic it receives.
	Route  []*MetaRouteDestination `protobuf:"bytes,3,rep,name=route,proto3" json:"route,omitempty"`
	Mirror *Destination            `protobuf:"bytes,5,opt,name=mirror,proto3" json:"mirror,omitempty"`
	// Percentage of the traffic to be mirrored by the `mirror` field.
	// If this field is absent, all the traffic (100%) will be mirrored.
	// Max value is 100.
	MirrorPercentage *Percent `protobuf:"bytes,6,opt,name=mirror_percentage,json=mirrorPercentage,proto3" json:"mirror_percentage,omitempty"`
	// Specifies a list of key-value pairs that should be mutated for each request. How to interpret the key-value pairs
	// depends on the codec implementation
	RequestMutation []*KeyValue `protobuf:"bytes,19,rep,name=request_mutation,json=requestMutation,proto3" json:"request_mutation,omitempty"`
	// Specifies a list of key-value pairs that should be mutated for each response. How to interpret the key-value pairs
	// depends on the codec implementation
	ResponseMutation     []*KeyValue `protobuf:"bytes,20,rep,name=response_mutation,json=responseMutation,proto3" json:"response_mutation,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *MetaRoute) Reset()         { *m = MetaRoute{} }
func (m *MetaRoute) String() string { return proto.CompactTextString(m) }
func (*MetaRoute) ProtoMessage()    {}
func (*MetaRoute) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e2715e051935576, []int{1}
}
func (m *MetaRoute) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MetaRoute) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MetaRoute.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MetaRoute) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetaRoute.Merge(m, src)
}
func (m *MetaRoute) XXX_Size() int {
	return m.Size()
}
func (m *MetaRoute) XXX_DiscardUnknown() {
	xxx_messageInfo_MetaRoute.DiscardUnknown(m)
}

var xxx_messageInfo_MetaRoute proto.InternalMessageInfo

func (m *MetaRoute) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MetaRoute) GetMatch() *MetaRouteMatch {
	if m != nil {
		return m.Match
	}
	return nil
}

func (m *MetaRoute) GetRoute() []*MetaRouteDestination {
	if m != nil {
		return m.Route
	}
	return nil
}

func (m *MetaRoute) GetMirror() *Destination {
	if m != nil {
		return m.Mirror
	}
	return nil
}

func (m *MetaRoute) GetMirrorPercentage() *Percent {
	if m != nil {
		return m.MirrorPercentage
	}
	return nil
}

func (m *MetaRoute) GetRequestMutation() []*KeyValue {
	if m != nil {
		return m.RequestMutation
	}
	return nil
}

func (m *MetaRoute) GetResponseMutation() []*KeyValue {
	if m != nil {
		return m.ResponseMutation
	}
	return nil
}

// KeyValue defines a Key /value pair.
type KeyValue struct {
	// Key name.
	Key string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	// alue.
	Value                string   `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KeyValue) Reset()         { *m = KeyValue{} }
func (m *KeyValue) String() string { return proto.CompactTextString(m) }
func (*KeyValue) ProtoMessage()    {}
func (*KeyValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e2715e051935576, []int{2}
}
func (m *KeyValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KeyValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KeyValue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KeyValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KeyValue.Merge(m, src)
}
func (m *KeyValue) XXX_Size() int {
	return m.Size()
}
func (m *KeyValue) XXX_DiscardUnknown() {
	xxx_messageInfo_KeyValue.DiscardUnknown(m)
}

var xxx_messageInfo_KeyValue proto.InternalMessageInfo

func (m *KeyValue) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *KeyValue) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type MetaRouteMatch struct {
	// If the value is empty and only the name of attribute is specified, presence of the attribute is checked.
	Attributes           map[string]*StringMatch `protobuf:"bytes,1,rep,name=attributes,proto3" json:"attributes,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *MetaRouteMatch) Reset()         { *m = MetaRouteMatch{} }
func (m *MetaRouteMatch) String() string { return proto.CompactTextString(m) }
func (*MetaRouteMatch) ProtoMessage()    {}
func (*MetaRouteMatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e2715e051935576, []int{3}
}
func (m *MetaRouteMatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MetaRouteMatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MetaRouteMatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MetaRouteMatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetaRouteMatch.Merge(m, src)
}
func (m *MetaRouteMatch) XXX_Size() int {
	return m.Size()
}
func (m *MetaRouteMatch) XXX_DiscardUnknown() {
	xxx_messageInfo_MetaRouteMatch.DiscardUnknown(m)
}

var xxx_messageInfo_MetaRouteMatch proto.InternalMessageInfo

func (m *MetaRouteMatch) GetAttributes() map[string]*StringMatch {
	if m != nil {
		return m.Attributes
	}
	return nil
}

// Describes how to match a given string in HTTP headers. Match is
// case-sensitive.
type StringMatch struct {
	// Types that are valid to be assigned to MatchType:
	//	*StringMatch_Exact
	//	*StringMatch_Prefix
	//	*StringMatch_Regex
	MatchType            isStringMatch_MatchType `protobuf_oneof:"match_type"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *StringMatch) Reset()         { *m = StringMatch{} }
func (m *StringMatch) String() string { return proto.CompactTextString(m) }
func (*StringMatch) ProtoMessage()    {}
func (*StringMatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e2715e051935576, []int{4}
}
func (m *StringMatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StringMatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StringMatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StringMatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StringMatch.Merge(m, src)
}
func (m *StringMatch) XXX_Size() int {
	return m.Size()
}
func (m *StringMatch) XXX_DiscardUnknown() {
	xxx_messageInfo_StringMatch.DiscardUnknown(m)
}

var xxx_messageInfo_StringMatch proto.InternalMessageInfo

type isStringMatch_MatchType interface {
	isStringMatch_MatchType()
	MarshalTo([]byte) (int, error)
	Size() int
}

type StringMatch_Exact struct {
	Exact string `protobuf:"bytes,1,opt,name=exact,proto3,oneof" json:"exact,omitempty"`
}
type StringMatch_Prefix struct {
	Prefix string `protobuf:"bytes,2,opt,name=prefix,proto3,oneof" json:"prefix,omitempty"`
}
type StringMatch_Regex struct {
	Regex string `protobuf:"bytes,3,opt,name=regex,proto3,oneof" json:"regex,omitempty"`
}

func (*StringMatch_Exact) isStringMatch_MatchType()  {}
func (*StringMatch_Prefix) isStringMatch_MatchType() {}
func (*StringMatch_Regex) isStringMatch_MatchType()  {}

func (m *StringMatch) GetMatchType() isStringMatch_MatchType {
	if m != nil {
		return m.MatchType
	}
	return nil
}

func (m *StringMatch) GetExact() string {
	if x, ok := m.GetMatchType().(*StringMatch_Exact); ok {
		return x.Exact
	}
	return ""
}

func (m *StringMatch) GetPrefix() string {
	if x, ok := m.GetMatchType().(*StringMatch_Prefix); ok {
		return x.Prefix
	}
	return ""
}

func (m *StringMatch) GetRegex() string {
	if x, ok := m.GetMatchType().(*StringMatch_Regex); ok {
		return x.Regex
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*StringMatch) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*StringMatch_Exact)(nil),
		(*StringMatch_Prefix)(nil),
		(*StringMatch_Regex)(nil),
	}
}

type MetaRouteDestination struct {
	// Destination uniquely identifies the instances of a service
	// to which the request/connection should be forwarded to.
	Destination *Destination `protobuf:"bytes,1,opt,name=destination,proto3" json:"destination,omitempty"`
	// The proportion of traffic to be forwarded to the service
	// version. (0-100). Sum of weights across destinations SHOULD BE == 100.
	// If there is only one destination in a rule, the weight value is assumed to
	// be 100.
	Weight               uint32   `protobuf:"varint,2,opt,name=weight,proto3" json:"weight,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MetaRouteDestination) Reset()         { *m = MetaRouteDestination{} }
func (m *MetaRouteDestination) String() string { return proto.CompactTextString(m) }
func (*MetaRouteDestination) ProtoMessage()    {}
func (*MetaRouteDestination) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e2715e051935576, []int{5}
}
func (m *MetaRouteDestination) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MetaRouteDestination) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MetaRouteDestination.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MetaRouteDestination) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetaRouteDestination.Merge(m, src)
}
func (m *MetaRouteDestination) XXX_Size() int {
	return m.Size()
}
func (m *MetaRouteDestination) XXX_DiscardUnknown() {
	xxx_messageInfo_MetaRouteDestination.DiscardUnknown(m)
}

var xxx_messageInfo_MetaRouteDestination proto.InternalMessageInfo

func (m *MetaRouteDestination) GetDestination() *Destination {
	if m != nil {
		return m.Destination
	}
	return nil
}

func (m *MetaRouteDestination) GetWeight() uint32 {
	if m != nil {
		return m.Weight
	}
	return 0
}

type Destination struct {
	// The name of a service from the service registry. Service
	// names are looked up from the platform's service registry (e.g.,
	// Kubernetes services, Consul services, etc.) and from the hosts
	// declared by [ServiceEntry](https://istio.io/docs/reference/config/networking/service-entry/#ServiceEntry). Traffic
	// forwarded to destinations that are not found in either of the two, will be dropped.
	//
	// *Note for Kubernetes users*: When short names are used (e.g. "reviews"
	// instead of "reviews.default.svc.cluster.local"), Istio will interpret
	// the short name based on the namespace of the rule, not the service. A
	// rule in the "default" namespace containing a host "reviews will be
	// interpreted as "reviews.default.svc.cluster.local", irrespective of
	// the actual namespace associated with the reviews service. To avoid
	// potential misconfiguration, it is recommended to always use fully
	// qualified domain names over short names.
	Host string `protobuf:"bytes,1,opt,name=host,proto3" json:"host,omitempty"`
	// The name of a subset within the service. Applicable only to services
	// within the mesh. The subset must be defined in a corresponding
	// DestinationRule.
	Subset string `protobuf:"bytes,2,opt,name=subset,proto3" json:"subset,omitempty"`
	// Specifies the port on the host that is being addressed. If a service
	// exposes only a single port it is not required to explicitly select the
	// port.
	Port                 *PortSelector `protobuf:"bytes,3,opt,name=port,proto3" json:"port,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *Destination) Reset()         { *m = Destination{} }
func (m *Destination) String() string { return proto.CompactTextString(m) }
func (*Destination) ProtoMessage()    {}
func (*Destination) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e2715e051935576, []int{6}
}
func (m *Destination) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Destination) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Destination.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Destination) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Destination.Merge(m, src)
}
func (m *Destination) XXX_Size() int {
	return m.Size()
}
func (m *Destination) XXX_DiscardUnknown() {
	xxx_messageInfo_Destination.DiscardUnknown(m)
}

var xxx_messageInfo_Destination proto.InternalMessageInfo

func (m *Destination) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *Destination) GetSubset() string {
	if m != nil {
		return m.Subset
	}
	return ""
}

func (m *Destination) GetPort() *PortSelector {
	if m != nil {
		return m.Port
	}
	return nil
}

// PortSelector specifies the number of a port to be used for
// matching or selection for final routing.
type PortSelector struct {
	// Valid port number
	Number               uint32   `protobuf:"varint,1,opt,name=number,proto3" json:"number,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PortSelector) Reset()         { *m = PortSelector{} }
func (m *PortSelector) String() string { return proto.CompactTextString(m) }
func (*PortSelector) ProtoMessage()    {}
func (*PortSelector) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e2715e051935576, []int{7}
}
func (m *PortSelector) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PortSelector) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PortSelector.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PortSelector) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PortSelector.Merge(m, src)
}
func (m *PortSelector) XXX_Size() int {
	return m.Size()
}
func (m *PortSelector) XXX_DiscardUnknown() {
	xxx_messageInfo_PortSelector.DiscardUnknown(m)
}

var xxx_messageInfo_PortSelector proto.InternalMessageInfo

func (m *PortSelector) GetNumber() uint32 {
	if m != nil {
		return m.Number
	}
	return 0
}

// LocalRateLimit defines local rate limit policies for MetaProtocol proxy
type LocalRateLimit struct {
	// The default token bucket configuration to use for rate limiting requests that are processed by
	// this filter.
	// Local rate limiter will first check the conditions, if a specific condition matches, then the token
	// bucket within that condition will be applied to the incoming request. All the other requests
	// that don't match the conditions will be rate limited by the default token bucket.
	// If the default token bucket is not specified, then the requests that don't match the conditions
	// will not be rate limited.
	// At least one of token_bucket or conditions should have value.
	TokenBucket *LocalRateLimit_TokenBucket `protobuf:"bytes,1,opt,name=token_bucket,json=tokenBucket,proto3" json:"token_bucket,omitempty"`
	// The more specific rate limit conditions, the first match will be used.
	Conditions           []*LocalRateLimit_Condition `protobuf:"bytes,2,rep,name=conditions,proto3" json:"conditions,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *LocalRateLimit) Reset()         { *m = LocalRateLimit{} }
func (m *LocalRateLimit) String() string { return proto.CompactTextString(m) }
func (*LocalRateLimit) ProtoMessage()    {}
func (*LocalRateLimit) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e2715e051935576, []int{8}
}
func (m *LocalRateLimit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LocalRateLimit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LocalRateLimit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LocalRateLimit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocalRateLimit.Merge(m, src)
}
func (m *LocalRateLimit) XXX_Size() int {
	return m.Size()
}
func (m *LocalRateLimit) XXX_DiscardUnknown() {
	xxx_messageInfo_LocalRateLimit.DiscardUnknown(m)
}

var xxx_messageInfo_LocalRateLimit proto.InternalMessageInfo

func (m *LocalRateLimit) GetTokenBucket() *LocalRateLimit_TokenBucket {
	if m != nil {
		return m.TokenBucket
	}
	return nil
}

func (m *LocalRateLimit) GetConditions() []*LocalRateLimit_Condition {
	if m != nil {
		return m.Conditions
	}
	return nil
}

// Configures a token bucket which is used for rate limiting.
type LocalRateLimit_TokenBucket struct {
	// The maximum tokens that the bucket can hold. This is also the number of tokens that the bucket
	// initially contains. The value must be greater than 0.
	MaxTokens uint32 `protobuf:"varint,1,opt,name=max_tokens,json=maxTokens,proto3" json:"max_tokens,omitempty"`
	// The number of tokens added to the bucket during each fill interval. The value must be greater than 0.
	//If not specified, defaults to a single token.
	TokensPerFill *types.UInt32Value `protobuf:"bytes,2,opt,name=tokens_per_fill,json=tokensPerFill,proto3" json:"tokens_per_fill,omitempty"`
	// The fill interval that tokens are added to the bucket. During each fill interval
	// `tokens_per_fill` are added to the bucket. The bucket will never contain more than
	// `max_tokens` tokens.
	FillInterval         *types.Duration `protobuf:"bytes,3,opt,name=fill_interval,json=fillInterval,proto3" json:"fill_interval,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *LocalRateLimit_TokenBucket) Reset()         { *m = LocalRateLimit_TokenBucket{} }
func (m *LocalRateLimit_TokenBucket) String() string { return proto.CompactTextString(m) }
func (*LocalRateLimit_TokenBucket) ProtoMessage()    {}
func (*LocalRateLimit_TokenBucket) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e2715e051935576, []int{8, 0}
}
func (m *LocalRateLimit_TokenBucket) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LocalRateLimit_TokenBucket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LocalRateLimit_TokenBucket.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LocalRateLimit_TokenBucket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocalRateLimit_TokenBucket.Merge(m, src)
}
func (m *LocalRateLimit_TokenBucket) XXX_Size() int {
	return m.Size()
}
func (m *LocalRateLimit_TokenBucket) XXX_DiscardUnknown() {
	xxx_messageInfo_LocalRateLimit_TokenBucket.DiscardUnknown(m)
}

var xxx_messageInfo_LocalRateLimit_TokenBucket proto.InternalMessageInfo

func (m *LocalRateLimit_TokenBucket) GetMaxTokens() uint32 {
	if m != nil {
		return m.MaxTokens
	}
	return 0
}

func (m *LocalRateLimit_TokenBucket) GetTokensPerFill() *types.UInt32Value {
	if m != nil {
		return m.TokensPerFill
	}
	return nil
}

func (m *LocalRateLimit_TokenBucket) GetFillInterval() *types.Duration {
	if m != nil {
		return m.FillInterval
	}
	return nil
}

// Condition defines a rate limit policy for a more specific condition
type LocalRateLimit_Condition struct {
	// Match conditions to be satisfied for the rate limit rule to be activated.
	// All conditions inside a single match block have AND semantic.
	// If the match is not specified, then all the incoming requests will be considered matched.
	Match *MetaRouteMatch `protobuf:"bytes,1,opt,name=match,proto3" json:"match,omitempty"`
	// The token bucket for this particular condition
	TokenBucket          *LocalRateLimit_TokenBucket `protobuf:"bytes,2,opt,name=token_bucket,json=tokenBucket,proto3" json:"token_bucket,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *LocalRateLimit_Condition) Reset()         { *m = LocalRateLimit_Condition{} }
func (m *LocalRateLimit_Condition) String() string { return proto.CompactTextString(m) }
func (*LocalRateLimit_Condition) ProtoMessage()    {}
func (*LocalRateLimit_Condition) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e2715e051935576, []int{8, 1}
}
func (m *LocalRateLimit_Condition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LocalRateLimit_Condition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LocalRateLimit_Condition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LocalRateLimit_Condition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocalRateLimit_Condition.Merge(m, src)
}
func (m *LocalRateLimit_Condition) XXX_Size() int {
	return m.Size()
}
func (m *LocalRateLimit_Condition) XXX_DiscardUnknown() {
	xxx_messageInfo_LocalRateLimit_Condition.DiscardUnknown(m)
}

var xxx_messageInfo_LocalRateLimit_Condition proto.InternalMessageInfo

func (m *LocalRateLimit_Condition) GetMatch() *MetaRouteMatch {
	if m != nil {
		return m.Match
	}
	return nil
}

func (m *LocalRateLimit_Condition) GetTokenBucket() *LocalRateLimit_TokenBucket {
	if m != nil {
		return m.TokenBucket
	}
	return nil
}

// GlobalRateLimit configures global rate limit service for MetaProtocol proxy
type GlobalRateLimit struct {
	// Match conditions to be satisfied for the rate limit rule to be activated.
	// All conditions inside a single match block have AND semantic.
	// If the match is not specified, then all the incoming requests will be considered matched.
	Match *MetaRouteMatch `protobuf:"bytes,1,opt,name=match,proto3" json:"match,omitempty"`
	// The rate limit domain to use when calling the rate limit service.
	Domain string `protobuf:"bytes,2,opt,name=domain,proto3" json:"domain,omitempty"`
	// The timeout in milliseconds for the rate limit service RPC. If not
	// set, this defaults to 20ms.
	RequestTimeout *types.Duration `protobuf:"bytes,3,opt,name=request_timeout,json=requestTimeout,proto3" json:"request_timeout,omitempty"`
	// The filter's behavior in case the rate limiting service does
	// not respond back. When it is set to true, Envoy will not allow traffic in case of
	// communication failure between rate limiting service and the proxy.
	DenyOnFail bool `protobuf:"varint,4,opt,name=deny_on_fail,json=denyOnFail,proto3" json:"deny_on_fail,omitempty"`
	// The cluster name of the external rate limit service provider.
	RateLimitService string `protobuf:"bytes,5,opt,name=rate_limit_service,json=rateLimitService,proto3" json:"rate_limit_service,omitempty"`
	// Defines what properties in the requests should be sent to the rate limit service
	Descriptors          []*GlobalRateLimit_Descriptor `protobuf:"bytes,6,rep,name=descriptors,proto3" json:"descriptors,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                      `json:"-"`
	XXX_unrecognized     []byte                        `json:"-"`
	XXX_sizecache        int32                         `json:"-"`
}

func (m *GlobalRateLimit) Reset()         { *m = GlobalRateLimit{} }
func (m *GlobalRateLimit) String() string { return proto.CompactTextString(m) }
func (*GlobalRateLimit) ProtoMessage()    {}
func (*GlobalRateLimit) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e2715e051935576, []int{9}
}
func (m *GlobalRateLimit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GlobalRateLimit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GlobalRateLimit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GlobalRateLimit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GlobalRateLimit.Merge(m, src)
}
func (m *GlobalRateLimit) XXX_Size() int {
	return m.Size()
}
func (m *GlobalRateLimit) XXX_DiscardUnknown() {
	xxx_messageInfo_GlobalRateLimit.DiscardUnknown(m)
}

var xxx_messageInfo_GlobalRateLimit proto.InternalMessageInfo

func (m *GlobalRateLimit) GetMatch() *MetaRouteMatch {
	if m != nil {
		return m.Match
	}
	return nil
}

func (m *GlobalRateLimit) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	return ""
}

func (m *GlobalRateLimit) GetRequestTimeout() *types.Duration {
	if m != nil {
		return m.RequestTimeout
	}
	return nil
}

func (m *GlobalRateLimit) GetDenyOnFail() bool {
	if m != nil {
		return m.DenyOnFail
	}
	return false
}

func (m *GlobalRateLimit) GetRateLimitService() string {
	if m != nil {
		return m.RateLimitService
	}
	return ""
}

func (m *GlobalRateLimit) GetDescriptors() []*GlobalRateLimit_Descriptor {
	if m != nil {
		return m.Descriptors
	}
	return nil
}

// Descriptor defines the mapping between the property in the request and the descriptor key in the rate
// limit server configuration
// Normally the property is the same as the descriptor key, but adding a mapping layer allows more flexibility
type GlobalRateLimit_Descriptor struct {
	// The property extracted from the requests
	Property string `protobuf:"bytes,1,opt,name=property,proto3" json:"property,omitempty"`
	// The corresponding descriptor key in the rate limit server configuration
	DescriptorKey        string   `protobuf:"bytes,2,opt,name=descriptor_key,json=descriptorKey,proto3" json:"descriptor_key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GlobalRateLimit_Descriptor) Reset()         { *m = GlobalRateLimit_Descriptor{} }
func (m *GlobalRateLimit_Descriptor) String() string { return proto.CompactTextString(m) }
func (*GlobalRateLimit_Descriptor) ProtoMessage()    {}
func (*GlobalRateLimit_Descriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e2715e051935576, []int{9, 0}
}
func (m *GlobalRateLimit_Descriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GlobalRateLimit_Descriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GlobalRateLimit_Descriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GlobalRateLimit_Descriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GlobalRateLimit_Descriptor.Merge(m, src)
}
func (m *GlobalRateLimit_Descriptor) XXX_Size() int {
	return m.Size()
}
func (m *GlobalRateLimit_Descriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_GlobalRateLimit_Descriptor.DiscardUnknown(m)
}

var xxx_messageInfo_GlobalRateLimit_Descriptor proto.InternalMessageInfo

func (m *GlobalRateLimit_Descriptor) GetProperty() string {
	if m != nil {
		return m.Property
	}
	return ""
}

func (m *GlobalRateLimit_Descriptor) GetDescriptorKey() string {
	if m != nil {
		return m.DescriptorKey
	}
	return ""
}

// Percent specifies a percentage in the range of [0.0, 100.0].
type Percent struct {
	Value                float64  `protobuf:"fixed64,1,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Percent) Reset()         { *m = Percent{} }
func (m *Percent) String() string { return proto.CompactTextString(m) }
func (*Percent) ProtoMessage()    {}
func (*Percent) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e2715e051935576, []int{10}
}
func (m *Percent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Percent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Percent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Percent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Percent.Merge(m, src)
}
func (m *Percent) XXX_Size() int {
	return m.Size()
}
func (m *Percent) XXX_DiscardUnknown() {
	xxx_messageInfo_Percent.DiscardUnknown(m)
}

var xxx_messageInfo_Percent proto.InternalMessageInfo

func (m *Percent) GetValue() float64 {
	if m != nil {
		return m.Value
	}
	return 0
}

func init() {
	proto.RegisterType((*MetaRouter)(nil), "metaprotocol.aeraki.io.v1alpha1.MetaRouter")
	proto.RegisterType((*MetaRoute)(nil), "metaprotocol.aeraki.io.v1alpha1.MetaRoute")
	proto.RegisterType((*KeyValue)(nil), "metaprotocol.aeraki.io.v1alpha1.KeyValue")
	proto.RegisterType((*MetaRouteMatch)(nil), "metaprotocol.aeraki.io.v1alpha1.MetaRouteMatch")
	proto.RegisterMapType((map[string]*StringMatch)(nil), "metaprotocol.aeraki.io.v1alpha1.MetaRouteMatch.AttributesEntry")
	proto.RegisterType((*StringMatch)(nil), "metaprotocol.aeraki.io.v1alpha1.StringMatch")
	proto.RegisterType((*MetaRouteDestination)(nil), "metaprotocol.aeraki.io.v1alpha1.MetaRouteDestination")
	proto.RegisterType((*Destination)(nil), "metaprotocol.aeraki.io.v1alpha1.Destination")
	proto.RegisterType((*PortSelector)(nil), "metaprotocol.aeraki.io.v1alpha1.PortSelector")
	proto.RegisterType((*LocalRateLimit)(nil), "metaprotocol.aeraki.io.v1alpha1.LocalRateLimit")
	proto.RegisterType((*LocalRateLimit_TokenBucket)(nil), "metaprotocol.aeraki.io.v1alpha1.LocalRateLimit.TokenBucket")
	proto.RegisterType((*LocalRateLimit_Condition)(nil), "metaprotocol.aeraki.io.v1alpha1.LocalRateLimit.Condition")
	proto.RegisterType((*GlobalRateLimit)(nil), "metaprotocol.aeraki.io.v1alpha1.GlobalRateLimit")
	proto.RegisterType((*GlobalRateLimit_Descriptor)(nil), "metaprotocol.aeraki.io.v1alpha1.GlobalRateLimit.Descriptor")
	proto.RegisterType((*Percent)(nil), "metaprotocol.aeraki.io.v1alpha1.Percent")
}

func init() {
	proto.RegisterFile("api/metaprotocol/v1alpha1/metaprotocol_metarouter.proto", fileDescriptor_1e2715e051935576)
}

var fileDescriptor_1e2715e051935576 = []byte{
	// 1096 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x96, 0x5b, 0x6f, 0x1b, 0x45,
	0x14, 0xc7, 0xbb, 0xbe, 0x11, 0x1f, 0xe7, 0xe2, 0x0e, 0xa1, 0x6c, 0x5d, 0x48, 0x22, 0x3f, 0x85,
	0x8a, 0xae, 0xa9, 0x2b, 0x54, 0xa0, 0x48, 0xa8, 0x6e, 0x5a, 0x7a, 0x15, 0xd1, 0x26, 0xad, 0x14,
	0x84, 0x58, 0x8d, 0xd7, 0x27, 0xf6, 0x28, 0xbb, 0x3b, 0xcb, 0xec, 0x38, 0xb1, 0x1f, 0x11, 0x1f,
	0x8a, 0x17, 0x1e, 0x79, 0xe0, 0x11, 0xf1, 0xc4, 0x13, 0xaa, 0xf2, 0x41, 0x10, 0x9a, 0x8b, 0xed,
	0x75, 0xa0, 0x72, 0x0c, 0xbc, 0xf9, 0x9c, 0xe3, 0xff, 0x6f, 0xe6, 0xcc, 0x9c, 0x3d, 0x67, 0xe0,
	0x2e, 0x4d, 0x59, 0x2b, 0x46, 0x49, 0x53, 0xc1, 0x25, 0x0f, 0x79, 0xd4, 0x3a, 0xbd, 0x4d, 0xa3,
	0x74, 0x40, 0x6f, 0xcf, 0x79, 0x03, 0x65, 0x08, 0x3e, 0x94, 0x28, 0x3c, 0xed, 0x23, 0xdb, 0xf9,
	0xb0, 0x47, 0x51, 0xd0, 0x13, 0xe6, 0x31, 0xee, 0x4d, 0xe4, 0x8d, 0xed, 0x3e, 0xe7, 0xfd, 0x08,
	0x5b, 0x6a, 0x81, 0x63, 0x86, 0x51, 0x2f, 0xe8, 0xe2, 0x80, 0x9e, 0x32, 0x6e, 0x09, 0x8d, 0x2d,
	0xfb, 0x07, 0x6d, 0x75, 0x87, 0xc7, 0xad, 0xde, 0x50, 0x50, 0xc9, 0x78, 0xf2, 0xa6, 0xf8, 0x99,
	0xa0, 0x69, 0x8a, 0x22, 0x33, 0xf1, 0xe6, 0xef, 0x05, 0x80, 0x17, 0x28, 0xa9, 0xaf, 0xb7, 0x45,
	0x36, 0xa1, 0x3c, 0xe0, 0x99, 0xcc, 0x5c, 0x67, 0xa7, 0xb8, 0x5b, 0xf5, 0x8d, 0x41, 0x1a, 0xb0,
	0xd2, 0xa7, 0x12, 0xcf, 0xe8, 0x38, 0x73, 0x0b, 0x3a, 0x30, 0xb5, 0x49, 0x07, 0x2a, 0x3a, 0xa5,
	0xcc, 0x2d, 0xee, 0x14, 0x77, 0x6b, 0xed, 0x9b, 0xde, 0x82, 0x9c, 0xbc, 0xe9, 0x72, 0xbe, 0x55,
	0x92, 0x23, 0xa8, 0x47, 0x3c, 0xa4, 0x51, 0x20, 0xa8, 0xc4, 0x20, 0x62, 0x31, 0x93, 0x6e, 0x69,
	0xc7, 0xd9, 0xad, 0xb5, 0x5b, 0x0b, 0x69, 0xcf, 0x95, 0xd0, 0xa7, 0x12, 0x9f, 0x2b, 0x99, 0xbf,
	0x1e, 0xcd, 0xd9, 0xe4, 0x1b, 0xb8, 0xda, 0x8f, 0x78, 0x77, 0x9e, 0x5d, 0xd6, 0xec, 0x8f, 0x16,
	0xb2, 0xbf, 0xd4, 0xca, 0x19, 0x7c, 0xa3, 0x3f, 0xef, 0x20, 0x37, 0xa0, 0x8a, 0xa3, 0x94, 0x0b,
	0x19, 0x48, 0xee, 0x6e, 0x9a, 0x93, 0x31, 0x8e, 0x43, 0xde, 0xfc, 0xb3, 0x08, 0xd5, 0x69, 0xae,
	0x84, 0x40, 0x29, 0xa1, 0x31, 0xba, 0xce, 0x8e, 0xb3, 0x5b, 0xf5, 0xf5, 0x6f, 0xf2, 0x10, 0xca,
	0x31, 0x95, 0xe1, 0xc0, 0x2d, 0x5c, 0x32, 0xd9, 0x29, 0xee, 0x85, 0x92, 0xf9, 0x46, 0x4d, 0x9e,
	0x41, 0x59, 0x1f, 0xa4, 0xbd, 0x81, 0x8f, 0x2f, 0x8f, 0xd9, 0xc3, 0x4c, 0xb2, 0x44, 0xd7, 0x8b,
	0x6f, 0x18, 0x64, 0x0f, 0x2a, 0x31, 0x13, 0x82, 0x0b, 0x7b, 0x4a, 0x1f, 0x2e, 0xa4, 0xe5, 0x21,
	0x56, 0x4b, 0x5e, 0xc2, 0x55, 0xf3, 0x2b, 0x48, 0x51, 0x84, 0x98, 0x48, 0xda, 0x47, 0xb7, 0xa2,
	0x81, 0xbb, 0x0b, 0x81, 0xfb, 0x46, 0xe2, 0xd7, 0x0d, 0x62, 0x7f, 0x4a, 0x20, 0x87, 0x50, 0x17,
	0xf8, 0xdd, 0x10, 0x33, 0x19, 0xc4, 0x43, 0xa9, 0x97, 0x74, 0xdf, 0xd6, 0x49, 0x7f, 0xb0, 0x90,
	0xfa, 0x0c, 0xc7, 0xaf, 0x68, 0x34, 0x44, 0x7f, 0xc3, 0x22, 0x5e, 0x58, 0x02, 0x79, 0x05, 0x57,
	0x05, 0x66, 0x29, 0x4f, 0x32, 0x9c, 0x61, 0x37, 0x97, 0xc5, 0xd6, 0x27, 0x8c, 0x09, 0xb7, 0xf9,
	0x39, 0xac, 0x4c, 0xa2, 0xe4, 0x1d, 0x28, 0x9e, 0xe0, 0xd8, 0xdc, 0x7e, 0xa7, 0xf8, 0xfa, 0x7e,
	0xc1, 0x57, 0x36, 0xb9, 0x0e, 0xe5, 0x53, 0x15, 0xd7, 0x15, 0x60, 0x03, 0xc6, 0xd3, 0xfc, 0xc3,
	0x81, 0xf5, 0xf9, 0xfb, 0x26, 0x01, 0x00, 0x95, 0x52, 0xb0, 0xae, 0xfe, 0xde, 0x1c, 0xbd, 0xc3,
	0x2f, 0x96, 0x2c, 0x1a, 0xef, 0xfe, 0x94, 0xf0, 0x30, 0x91, 0x62, 0xec, 0xe7, 0x90, 0x8d, 0x13,
	0xd8, 0xb8, 0x10, 0x26, 0xf5, 0xdc, 0xc6, 0xcd, 0x9e, 0x3b, 0xf9, 0x3d, 0x5f, 0xa6, 0x40, 0x0e,
	0xa4, 0x60, 0x49, 0xdf, 0x96, 0xac, 0x96, 0x7e, 0x56, 0xf8, 0xc4, 0x69, 0x22, 0xd4, 0x72, 0x11,
	0x72, 0x0d, 0xca, 0x38, 0xa2, 0xa1, 0x34, 0x4b, 0x3d, 0xbe, 0xe2, 0x1b, 0x93, 0xb8, 0x50, 0x49,
	0x05, 0x1e, 0xb3, 0x91, 0x39, 0xa3, 0xc7, 0x57, 0x7c, 0x6b, 0x2b, 0x85, 0xc0, 0x3e, 0x8e, 0xdc,
	0xe2, 0x44, 0xa1, 0xcd, 0xce, 0x2a, 0x80, 0xfe, 0x30, 0x02, 0x39, 0x4e, 0xb1, 0xf9, 0x83, 0x03,
	0x9b, 0xff, 0x54, 0xf0, 0xe4, 0x00, 0x6a, 0xbd, 0x99, 0xa9, 0x97, 0x5d, 0xb2, 0xdc, 0xcd, 0x7d,
	0xe5, 0x29, 0xe4, 0x1a, 0x54, 0xce, 0x90, 0xf5, 0x07, 0x52, 0xef, 0x76, 0xcd, 0xb7, 0x56, 0xf3,
	0x7b, 0x07, 0x6a, 0xf9, 0xc5, 0xdf, 0x85, 0x92, 0xea, 0xad, 0xf9, 0x82, 0xd0, 0x0e, 0x05, 0xc8,
	0x86, 0xdd, 0x0c, 0x0d, 0xa0, 0xea, 0x5b, 0x8b, 0xdc, 0x87, 0x92, 0xea, 0x2b, 0x3a, 0xd7, 0x5a,
	0xfb, 0xd6, 0xe2, 0x8f, 0x88, 0x0b, 0x79, 0x80, 0x11, 0x86, 0x92, 0x0b, 0x5f, 0x4b, 0x9b, 0x6d,
	0x58, 0xcd, 0x7b, 0xd5, 0x52, 0xc9, 0x30, 0xee, 0xa2, 0xd0, 0xbb, 0x58, 0xf3, 0xad, 0xf5, 0xb4,
	0xb4, 0x52, 0xa8, 0x17, 0x4d, 0x8b, 0x6a, 0xfe, 0x5c, 0x82, 0xf5, 0xf9, 0x16, 0x4b, 0xbe, 0x85,
	0x55, 0xc9, 0x4f, 0x30, 0x09, 0xba, 0xc3, 0xf0, 0x04, 0xa5, 0x3d, 0xb8, 0x7b, 0x4b, 0x76, 0x6a,
	0xef, 0x50, 0x31, 0x3a, 0x1a, 0xe1, 0xd7, 0xe4, 0xcc, 0x20, 0x47, 0x00, 0x21, 0x4f, 0x7a, 0x4c,
	0x9d, 0x93, 0x99, 0x37, 0xb5, 0xf6, 0xa7, 0xcb, 0xd2, 0x1f, 0x4c, 0x08, 0x7e, 0x0e, 0xd6, 0xf8,
	0xd1, 0x81, 0x5a, 0x6e, 0x5d, 0xf2, 0xbe, 0xaa, 0x94, 0x51, 0xa0, 0x57, 0xcf, 0xec, 0x29, 0x54,
	0x63, 0x3a, 0xd2, 0xff, 0xc9, 0xc8, 0x1e, 0x6c, 0x98, 0x90, 0xea, 0x62, 0xc1, 0x31, 0x8b, 0x22,
	0x5b, 0xf3, 0xef, 0x79, 0x66, 0xac, 0x7a, 0x93, 0xb1, 0xea, 0xbd, 0x7c, 0x92, 0xc8, 0x3b, 0x6d,
	0xd3, 0x09, 0xd6, 0x8c, 0x68, 0x1f, 0xc5, 0x23, 0x16, 0x45, 0xe4, 0x01, 0xac, 0x29, 0x69, 0xc0,
	0x12, 0x89, 0xe2, 0x94, 0x46, 0xf6, 0x0a, 0xaf, 0xff, 0x8d, 0xb1, 0x67, 0x47, 0xb7, 0x29, 0x87,
	0x55, 0x25, 0x7a, 0x62, 0x35, 0x8d, 0x9f, 0x1c, 0xa8, 0x4e, 0x73, 0x22, 0x4f, 0x27, 0x83, 0xc3,
	0xf9, 0x57, 0x83, 0xc3, 0xf6, 0x19, 0x33, 0x3d, 0xc2, 0x0b, 0xd7, 0x59, 0xf8, 0xcf, 0xd7, 0x69,
	0x3f, 0x8b, 0xdc, 0x9d, 0x36, 0x7f, 0x2b, 0xc2, 0xc6, 0x85, 0x69, 0xfa, 0xbf, 0x26, 0x71, 0x03,
	0x2a, 0x3d, 0x1e, 0x53, 0x96, 0xe4, 0x1b, 0xa9, 0x75, 0x91, 0x0e, 0x4c, 0x5a, 0x7e, 0x20, 0x59,
	0x8c, 0x7c, 0x28, 0x17, 0x5e, 0x81, 0xbf, 0x6e, 0x15, 0x87, 0x46, 0x40, 0x76, 0x60, 0xb5, 0x87,
	0xc9, 0x38, 0xe0, 0x49, 0x70, 0x4c, 0x59, 0xa4, 0x9f, 0x27, 0x2b, 0x3e, 0x28, 0xdf, 0x57, 0xc9,
	0x23, 0xca, 0x22, 0x72, 0x1b, 0xc8, 0xec, 0x89, 0x11, 0x64, 0x28, 0x4e, 0x59, 0x88, 0x7a, 0x88,
	0xda, 0xed, 0xd4, 0xc5, 0x24, 0xf5, 0x03, 0x13, 0x24, 0x5d, 0xdd, 0x81, 0x42, 0xc1, 0x52, 0xc9,
	0x45, 0xe6, 0x56, 0x74, 0xa9, 0xdf, 0x5b, 0xf6, 0x59, 0xa2, 0x3a, 0x92, 0x65, 0xcc, 0x1a, 0xd2,
	0x04, 0xda, 0x38, 0x02, 0x98, 0xc5, 0xc9, 0x36, 0xac, 0xa4, 0x82, 0xa7, 0x28, 0xe4, 0xdc, 0x2c,
	0x9a, 0x3a, 0xc9, 0x4d, 0x58, 0x9f, 0xa9, 0x03, 0xd5, 0xf9, 0x73, 0x07, 0xba, 0x36, 0x0b, 0x3d,
	0xc3, 0x71, 0x73, 0x1b, 0xde, 0xb2, 0xb3, 0x59, 0xbd, 0x1b, 0xcd, 0x4c, 0x50, 0x50, 0xc7, 0x76,
	0xf9, 0xce, 0xc3, 0x5f, 0xce, 0xb7, 0x9c, 0x5f, 0xcf, 0xb7, 0x9c, 0xd7, 0xe7, 0x5b, 0xce, 0xd7,
	0x77, 0xfb, 0x4c, 0x0e, 0x86, 0x5d, 0x2f, 0xe4, 0x71, 0xcb, 0x64, 0x75, 0x2b, 0xc6, 0x6c, 0x60,
	0x7f, 0xb7, 0xde, 0xf8, 0x86, 0xee, 0x56, 0xb4, 0xeb, 0xce, 0x5f, 0x01, 0x00, 0x00, 0xff, 0xff,
	0x81, 0x99, 0x95, 0xdc, 0x67, 0x0b, 0x00, 0x00,
}

func (m *MetaRouter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetaRouter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MetaRouter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ExportTo) > 0 {
		for iNdEx := len(m.ExportTo) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ExportTo[iNdEx])
			copy(dAtA[i:], m.ExportTo[iNdEx])
			i = encodeVarintMetaprotocolMetarouter(dAtA, i, uint64(len(m.ExportTo[iNdEx])))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xa2
		}
	}
	if m.GlobalRateLimit != nil {
		{
			size, err := m.GlobalRateLimit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMetaprotocolMetarouter(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.LocalRateLimit != nil {
		{
			size, err := m.LocalRateLimit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMetaprotocolMetarouter(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Routes) > 0 {
		for iNdEx := len(m.Routes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Routes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMetaprotocolMetarouter(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Gateways) > 0 {
		for iNdEx := len(m.Gateways) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Gateways[iNdEx])
			copy(dAtA[i:], m.Gateways[iNdEx])
			i = encodeVarintMetaprotocolMetarouter(dAtA, i, uint64(len(m.Gateways[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Hosts) > 0 {
		for iNdEx := len(m.Hosts) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Hosts[iNdEx])
			copy(dAtA[i:], m.Hosts[iNdEx])
			i = encodeVarintMetaprotocolMetarouter(dAtA, i, uint64(len(m.Hosts[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MetaRoute) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetaRoute) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MetaRoute) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ResponseMutation) > 0 {
		for iNdEx := len(m.ResponseMutation) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ResponseMutation[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMetaprotocolMetarouter(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.RequestMutation) > 0 {
		for iNdEx := len(m.RequestMutation) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RequestMutation[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMetaprotocolMetarouter(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x9a
		}
	}
	if m.MirrorPercentage != nil {
		{
			size, err := m.MirrorPercentage.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMetaprotocolMetarouter(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Mirror != nil {
		{
			size, err := m.Mirror.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMetaprotocolMetarouter(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Route) > 0 {
		for iNdEx := len(m.Route) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Route[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMetaprotocolMetarouter(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Match != nil {
		{
			size, err := m.Match.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMetaprotocolMetarouter(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMetaprotocolMetarouter(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *KeyValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KeyValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KeyValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintMetaprotocolMetarouter(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintMetaprotocolMetarouter(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MetaRouteMatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetaRouteMatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MetaRouteMatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Attributes) > 0 {
		for k := range m.Attributes {
			v := m.Attributes[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintMetaprotocolMetarouter(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintMetaprotocolMetarouter(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintMetaprotocolMetarouter(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *StringMatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StringMatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StringMatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MatchType != nil {
		{
			size := m.MatchType.Size()
			i -= size
			if _, err := m.MatchType.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *StringMatch_Exact) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StringMatch_Exact) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Exact)
	copy(dAtA[i:], m.Exact)
	i = encodeVarintMetaprotocolMetarouter(dAtA, i, uint64(len(m.Exact)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}
func (m *StringMatch_Prefix) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StringMatch_Prefix) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Prefix)
	copy(dAtA[i:], m.Prefix)
	i = encodeVarintMetaprotocolMetarouter(dAtA, i, uint64(len(m.Prefix)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *StringMatch_Regex) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StringMatch_Regex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Regex)
	copy(dAtA[i:], m.Regex)
	i = encodeVarintMetaprotocolMetarouter(dAtA, i, uint64(len(m.Regex)))
	i--
	dAtA[i] = 0x1a
	return len(dAtA) - i, nil
}
func (m *MetaRouteDestination) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetaRouteDestination) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MetaRouteDestination) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Weight != 0 {
		i = encodeVarintMetaprotocolMetarouter(dAtA, i, uint64(m.Weight))
		i--
		dAtA[i] = 0x10
	}
	if m.Destination != nil {
		{
			size, err := m.Destination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMetaprotocolMetarouter(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Destination) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Destination) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Destination) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Port != nil {
		{
			size, err := m.Port.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMetaprotocolMetarouter(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Subset) > 0 {
		i -= len(m.Subset)
		copy(dAtA[i:], m.Subset)
		i = encodeVarintMetaprotocolMetarouter(dAtA, i, uint64(len(m.Subset)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Host) > 0 {
		i -= len(m.Host)
		copy(dAtA[i:], m.Host)
		i = encodeVarintMetaprotocolMetarouter(dAtA, i, uint64(len(m.Host)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PortSelector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PortSelector) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PortSelector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Number != 0 {
		i = encodeVarintMetaprotocolMetarouter(dAtA, i, uint64(m.Number))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LocalRateLimit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocalRateLimit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LocalRateLimit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Conditions) > 0 {
		for iNdEx := len(m.Conditions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Conditions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMetaprotocolMetarouter(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.TokenBucket != nil {
		{
			size, err := m.TokenBucket.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMetaprotocolMetarouter(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LocalRateLimit_TokenBucket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocalRateLimit_TokenBucket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LocalRateLimit_TokenBucket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.FillInterval != nil {
		{
			size, err := m.FillInterval.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMetaprotocolMetarouter(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.TokensPerFill != nil {
		{
			size, err := m.TokensPerFill.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMetaprotocolMetarouter(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.MaxTokens != 0 {
		i = encodeVarintMetaprotocolMetarouter(dAtA, i, uint64(m.MaxTokens))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LocalRateLimit_Condition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocalRateLimit_Condition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LocalRateLimit_Condition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TokenBucket != nil {
		{
			size, err := m.TokenBucket.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMetaprotocolMetarouter(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Match != nil {
		{
			size, err := m.Match.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMetaprotocolMetarouter(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GlobalRateLimit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalRateLimit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalRateLimit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Descriptors) > 0 {
		for iNdEx := len(m.Descriptors) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Descriptors[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMetaprotocolMetarouter(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.RateLimitService) > 0 {
		i -= len(m.RateLimitService)
		copy(dAtA[i:], m.RateLimitService)
		i = encodeVarintMetaprotocolMetarouter(dAtA, i, uint64(len(m.RateLimitService)))
		i--
		dAtA[i] = 0x2a
	}
	if m.DenyOnFail {
		i--
		if m.DenyOnFail {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.RequestTimeout != nil {
		{
			size, err := m.RequestTimeout.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMetaprotocolMetarouter(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Domain) > 0 {
		i -= len(m.Domain)
		copy(dAtA[i:], m.Domain)
		i = encodeVarintMetaprotocolMetarouter(dAtA, i, uint64(len(m.Domain)))
		i--
		dAtA[i] = 0x12
	}
	if m.Match != nil {
		{
			size, err := m.Match.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMetaprotocolMetarouter(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GlobalRateLimit_Descriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalRateLimit_Descriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalRateLimit_Descriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DescriptorKey) > 0 {
		i -= len(m.DescriptorKey)
		copy(dAtA[i:], m.DescriptorKey)
		i = encodeVarintMetaprotocolMetarouter(dAtA, i, uint64(len(m.DescriptorKey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Property) > 0 {
		i -= len(m.Property)
		copy(dAtA[i:], m.Property)
		i = encodeVarintMetaprotocolMetarouter(dAtA, i, uint64(len(m.Property)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Percent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Percent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Percent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Value != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Value))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func encodeVarintMetaprotocolMetarouter(dAtA []byte, offset int, v uint64) int {
	offset -= sovMetaprotocolMetarouter(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MetaRouter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Hosts) > 0 {
		for _, s := range m.Hosts {
			l = len(s)
			n += 1 + l + sovMetaprotocolMetarouter(uint64(l))
		}
	}
	if len(m.Gateways) > 0 {
		for _, s := range m.Gateways {
			l = len(s)
			n += 1 + l + sovMetaprotocolMetarouter(uint64(l))
		}
	}
	if len(m.Routes) > 0 {
		for _, e := range m.Routes {
			l = e.Size()
			n += 1 + l + sovMetaprotocolMetarouter(uint64(l))
		}
	}
	if m.LocalRateLimit != nil {
		l = m.LocalRateLimit.Size()
		n += 1 + l + sovMetaprotocolMetarouter(uint64(l))
	}
	if m.GlobalRateLimit != nil {
		l = m.GlobalRateLimit.Size()
		n += 1 + l + sovMetaprotocolMetarouter(uint64(l))
	}
	if len(m.ExportTo) > 0 {
		for _, s := range m.ExportTo {
			l = len(s)
			n += 2 + l + sovMetaprotocolMetarouter(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MetaRoute) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMetaprotocolMetarouter(uint64(l))
	}
	if m.Match != nil {
		l = m.Match.Size()
		n += 1 + l + sovMetaprotocolMetarouter(uint64(l))
	}
	if len(m.Route) > 0 {
		for _, e := range m.Route {
			l = e.Size()
			n += 1 + l + sovMetaprotocolMetarouter(uint64(l))
		}
	}
	if m.Mirror != nil {
		l = m.Mirror.Size()
		n += 1 + l + sovMetaprotocolMetarouter(uint64(l))
	}
	if m.MirrorPercentage != nil {
		l = m.MirrorPercentage.Size()
		n += 1 + l + sovMetaprotocolMetarouter(uint64(l))
	}
	if len(m.RequestMutation) > 0 {
		for _, e := range m.RequestMutation {
			l = e.Size()
			n += 2 + l + sovMetaprotocolMetarouter(uint64(l))
		}
	}
	if len(m.ResponseMutation) > 0 {
		for _, e := range m.ResponseMutation {
			l = e.Size()
			n += 2 + l + sovMetaprotocolMetarouter(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *KeyValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovMetaprotocolMetarouter(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovMetaprotocolMetarouter(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MetaRouteMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Attributes) > 0 {
		for k, v := range m.Attributes {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovMetaprotocolMetarouter(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovMetaprotocolMetarouter(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovMetaprotocolMetarouter(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StringMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MatchType != nil {
		n += m.MatchType.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StringMatch_Exact) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Exact)
	n += 1 + l + sovMetaprotocolMetarouter(uint64(l))
	return n
}
func (m *StringMatch_Prefix) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Prefix)
	n += 1 + l + sovMetaprotocolMetarouter(uint64(l))
	return n
}
func (m *StringMatch_Regex) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Regex)
	n += 1 + l + sovMetaprotocolMetarouter(uint64(l))
	return n
}
func (m *MetaRouteDestination) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Destination != nil {
		l = m.Destination.Size()
		n += 1 + l + sovMetaprotocolMetarouter(uint64(l))
	}
	if m.Weight != 0 {
		n += 1 + sovMetaprotocolMetarouter(uint64(m.Weight))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Destination) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Host)
	if l > 0 {
		n += 1 + l + sovMetaprotocolMetarouter(uint64(l))
	}
	l = len(m.Subset)
	if l > 0 {
		n += 1 + l + sovMetaprotocolMetarouter(uint64(l))
	}
	if m.Port != nil {
		l = m.Port.Size()
		n += 1 + l + sovMetaprotocolMetarouter(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PortSelector) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Number != 0 {
		n += 1 + sovMetaprotocolMetarouter(uint64(m.Number))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LocalRateLimit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TokenBucket != nil {
		l = m.TokenBucket.Size()
		n += 1 + l + sovMetaprotocolMetarouter(uint64(l))
	}
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 1 + l + sovMetaprotocolMetarouter(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LocalRateLimit_TokenBucket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MaxTokens != 0 {
		n += 1 + sovMetaprotocolMetarouter(uint64(m.MaxTokens))
	}
	if m.TokensPerFill != nil {
		l = m.TokensPerFill.Size()
		n += 1 + l + sovMetaprotocolMetarouter(uint64(l))
	}
	if m.FillInterval != nil {
		l = m.FillInterval.Size()
		n += 1 + l + sovMetaprotocolMetarouter(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LocalRateLimit_Condition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Match != nil {
		l = m.Match.Size()
		n += 1 + l + sovMetaprotocolMetarouter(uint64(l))
	}
	if m.TokenBucket != nil {
		l = m.TokenBucket.Size()
		n += 1 + l + sovMetaprotocolMetarouter(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GlobalRateLimit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Match != nil {
		l = m.Match.Size()
		n += 1 + l + sovMetaprotocolMetarouter(uint64(l))
	}
	l = len(m.Domain)
	if l > 0 {
		n += 1 + l + sovMetaprotocolMetarouter(uint64(l))
	}
	if m.RequestTimeout != nil {
		l = m.RequestTimeout.Size()
		n += 1 + l + sovMetaprotocolMetarouter(uint64(l))
	}
	if m.DenyOnFail {
		n += 2
	}
	l = len(m.RateLimitService)
	if l > 0 {
		n += 1 + l + sovMetaprotocolMetarouter(uint64(l))
	}
	if len(m.Descriptors) > 0 {
		for _, e := range m.Descriptors {
			l = e.Size()
			n += 1 + l + sovMetaprotocolMetarouter(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GlobalRateLimit_Descriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Property)
	if l > 0 {
		n += 1 + l + sovMetaprotocolMetarouter(uint64(l))
	}
	l = len(m.DescriptorKey)
	if l > 0 {
		n += 1 + l + sovMetaprotocolMetarouter(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Percent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != 0 {
		n += 9
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovMetaprotocolMetarouter(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMetaprotocolMetarouter(x uint64) (n int) {
	return sovMetaprotocolMetarouter(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MetaRouter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetaprotocolMetarouter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetaRouter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetaRouter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hosts", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaprotocolMetarouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hosts = append(m.Hosts, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gateways", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaprotocolMetarouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Gateways = append(m.Gateways, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Routes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaprotocolMetarouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Routes = append(m.Routes, &MetaRoute{})
			if err := m.Routes[len(m.Routes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalRateLimit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaprotocolMetarouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LocalRateLimit == nil {
				m.LocalRateLimit = &LocalRateLimit{}
			}
			if err := m.LocalRateLimit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GlobalRateLimit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaprotocolMetarouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GlobalRateLimit == nil {
				m.GlobalRateLimit = &GlobalRateLimit{}
			}
			if err := m.GlobalRateLimit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExportTo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaprotocolMetarouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExportTo = append(m.ExportTo, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetaprotocolMetarouter(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetaRoute) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetaprotocolMetarouter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetaRoute: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetaRoute: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaprotocolMetarouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Match", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaprotocolMetarouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Match == nil {
				m.Match = &MetaRouteMatch{}
			}
			if err := m.Match.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Route", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaprotocolMetarouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Route = append(m.Route, &MetaRouteDestination{})
			if err := m.Route[len(m.Route)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mirror", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaprotocolMetarouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mirror == nil {
				m.Mirror = &Destination{}
			}
			if err := m.Mirror.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MirrorPercentage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaprotocolMetarouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MirrorPercentage == nil {
				m.MirrorPercentage = &Percent{}
			}
			if err := m.MirrorPercentage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestMutation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaprotocolMetarouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestMutation = append(m.RequestMutation, &KeyValue{})
			if err := m.RequestMutation[len(m.RequestMutation)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseMutation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaprotocolMetarouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResponseMutation = append(m.ResponseMutation, &KeyValue{})
			if err := m.ResponseMutation[len(m.ResponseMutation)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetaprotocolMetarouter(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KeyValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetaprotocolMetarouter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KeyValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KeyValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaprotocolMetarouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaprotocolMetarouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetaprotocolMetarouter(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetaRouteMatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetaprotocolMetarouter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetaRouteMatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetaRouteMatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaprotocolMetarouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Attributes == nil {
				m.Attributes = make(map[string]*StringMatch)
			}
			var mapkey string
			var mapvalue *StringMatch
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMetaprotocolMetarouter
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMetaprotocolMetarouter
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthMetaprotocolMetarouter
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthMetaprotocolMetarouter
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMetaprotocolMetarouter
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthMetaprotocolMetarouter
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthMetaprotocolMetarouter
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &StringMatch{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMetaprotocolMetarouter(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthMetaprotocolMetarouter
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Attributes[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetaprotocolMetarouter(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StringMatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetaprotocolMetarouter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StringMatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StringMatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exact", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaprotocolMetarouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MatchType = &StringMatch_Exact{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaprotocolMetarouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MatchType = &StringMatch_Prefix{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Regex", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaprotocolMetarouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MatchType = &StringMatch_Regex{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetaprotocolMetarouter(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetaRouteDestination) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetaprotocolMetarouter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetaRouteDestination: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetaRouteDestination: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Destination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaprotocolMetarouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Destination == nil {
				m.Destination = &Destination{}
			}
			if err := m.Destination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weight", wireType)
			}
			m.Weight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaprotocolMetarouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Weight |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetaprotocolMetarouter(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Destination) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetaprotocolMetarouter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Destination: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Destination: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaprotocolMetarouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Host = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subset", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaprotocolMetarouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subset = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaprotocolMetarouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Port == nil {
				m.Port = &PortSelector{}
			}
			if err := m.Port.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetaprotocolMetarouter(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PortSelector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetaprotocolMetarouter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PortSelector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PortSelector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			m.Number = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaprotocolMetarouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Number |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetaprotocolMetarouter(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocalRateLimit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetaprotocolMetarouter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LocalRateLimit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LocalRateLimit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenBucket", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaprotocolMetarouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TokenBucket == nil {
				m.TokenBucket = &LocalRateLimit_TokenBucket{}
			}
			if err := m.TokenBucket.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaprotocolMetarouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, &LocalRateLimit_Condition{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetaprotocolMetarouter(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocalRateLimit_TokenBucket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetaprotocolMetarouter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TokenBucket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TokenBucket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTokens", wireType)
			}
			m.MaxTokens = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaprotocolMetarouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxTokens |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokensPerFill", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaprotocolMetarouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TokensPerFill == nil {
				m.TokensPerFill = &types.UInt32Value{}
			}
			if err := m.TokensPerFill.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FillInterval", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaprotocolMetarouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FillInterval == nil {
				m.FillInterval = &types.Duration{}
			}
			if err := m.FillInterval.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetaprotocolMetarouter(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocalRateLimit_Condition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetaprotocolMetarouter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Condition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Condition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Match", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaprotocolMetarouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Match == nil {
				m.Match = &MetaRouteMatch{}
			}
			if err := m.Match.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenBucket", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaprotocolMetarouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TokenBucket == nil {
				m.TokenBucket = &LocalRateLimit_TokenBucket{}
			}
			if err := m.TokenBucket.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetaprotocolMetarouter(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalRateLimit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetaprotocolMetarouter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalRateLimit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalRateLimit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Match", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaprotocolMetarouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Match == nil {
				m.Match = &MetaRouteMatch{}
			}
			if err := m.Match.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaprotocolMetarouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestTimeout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaprotocolMetarouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RequestTimeout == nil {
				m.RequestTimeout = &types.Duration{}
			}
			if err := m.RequestTimeout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DenyOnFail", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaprotocolMetarouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DenyOnFail = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RateLimitService", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaprotocolMetarouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RateLimitService = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Descriptors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaprotocolMetarouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Descriptors = append(m.Descriptors, &GlobalRateLimit_Descriptor{})
			if err := m.Descriptors[len(m.Descriptors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetaprotocolMetarouter(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalRateLimit_Descriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetaprotocolMetarouter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Descriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Descriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Property", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaprotocolMetarouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Property = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DescriptorKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaprotocolMetarouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DescriptorKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetaprotocolMetarouter(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Percent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetaprotocolMetarouter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Percent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Percent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Value = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipMetaprotocolMetarouter(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetaprotocolMetarouter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMetaprotocolMetarouter(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMetaprotocolMetarouter
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMetaprotocolMetarouter
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMetaprotocolMetarouter
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMetaprotocolMetarouter
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupMetaprotocolMetarouter
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthMetaprotocolMetarouter
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthMetaprotocolMetarouter        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMetaprotocolMetarouter          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupMetaprotocolMetarouter = fmt.Errorf("proto: unexpected end of group")
)
